var documenterSearchIndex = {"docs":
[{"location":"#Rolling.jl-Documentation","page":"Rolling.jl Documentation","title":"Rolling.jl Documentation","text":"","category":"section"},{"location":"","page":"Rolling.jl Documentation","title":"Rolling.jl Documentation","text":"using Plots\nusing Rolling\n\nx = range(1, 10; length=100)\ny = sin.(x) + 0.5 * rand(length(x))\n\nplot(x, y; label=\"raw\", title=\"Rolling means\")\n\nfor window in [5, 10, 20]\n    state = FixedWindowAssociativeOp{Float64}(+, window; emit_early=false)\n\n    z = []\n    for value in y\n        new_value = update_state!(state, value)\n        if !isnothing(new_value)\n            push!(z, new_value / window)\n        else\n            push!(z, NaN)\n        end\n    end\n\n    plot!(x, z; label=\"mean $window\", lw=2)\nend\ncurrent()","category":"page"},{"location":"","page":"Rolling.jl Documentation","title":"Rolling.jl Documentation","text":"Modules = [Rolling]","category":"page"},{"location":"#Rolling.FixedWindowAssociativeOp","page":"Rolling.jl Documentation","title":"Rolling.FixedWindowAssociativeOp","text":"FixedWindowAssociativeOp{T}\n\nState necessary for accumulation over a rolling window of fixed size.\n\nFields\n\nwindow_state::WindowedAssociativeOpState{T}: The underlying general-window state.\nremaining_window::Int: How much of the window remains to be filled. Initially this will   be set to the window size, and will then reduce for every value added until it reaches   zero.\n\n\n\n\n\n","category":"type"},{"location":"#Rolling.FixedWindowAssociativeOp-Union{Tuple{T}, Tuple{Function,Integer}} where T","page":"Rolling.jl Documentation","title":"Rolling.FixedWindowAssociativeOp","text":"FixedWindowAssociativeOp{T}\n\nConstruct a new empty instance of FixedWindowAssociativeOp.\n\nArguments\n\nop::Function: Any binary, associative, function.\nwindow::Integer: The fixed window size.\nemit_early::Bool: Iff true, compute a value before the window is full.\n\n\n\n\n\n","category":"method"},{"location":"#Rolling.WindowedAssociativeOpState","page":"Rolling.jl Documentation","title":"Rolling.WindowedAssociativeOpState","text":"WindowedAssociativeOpState{T}\n\nState associated with a windowed aggregation of a binary associative operator, in a numerically accurate fashion.\n\nWherever summation is discussed, we can consider any alternative binary, associative, operator. For example: +, *, max, min, &&, union\n\nNB. It is interesting to observe that commutativity is not required by this algorithm, which is one of the reasons that it enjoys stable numerical performance.\n\nConceptually the window is maintained in two buffers:\n\n    [---- A ---)[----- B ------)\n        <                      >    <-- current window finishes at the end of B, and\n                                        starts somewhere in A.\n\nA is stored as a sequence of cumulative sums, such that as the \"<\" advances we merely pick out the correct element:\n\n    x_i,   x_i-1 + x_i,  x_i-2 + x_i-1 + x_i\n\nB is stored as both:\n\nThe sequence of values seen:  x_i+1,  x_i+2,  x_i+3,  ...\nThe total of that sequence:  x_i+1 + x_i+2 + x_i+3 + ...\n\nWhen the \"<\" advances from A to B, we discard A, and the subset of B remaining after < becomes the new A. In becoming A, we transform its representation into that of the cumulative sums. We create a new, empty, B.\n\nO(1) amortized runtime complexity, and O(L) space complexity, where L is the typical window length.\n\nFields\n\nvalue_count::Int: The size of the window on the last update.\nop::Function: Any binary, associative, function.\nprevious_cumsum::Array{T, 1}: Corresponds to array A above.\nri_previous_cumsum::Int: A reverse index into previous_cumsum, once it contains   values. It should be subtracted from end in order to obtain the appropriate index.\nvalues::Array{T, 1}: Corresponds to array B above.\nsum::Union{Nothing, T}: The sum of the elements in values.\n\n\n\n\n\n","category":"type"},{"location":"#Rolling.WindowedAssociativeOpState-Union{Tuple{Function}, Tuple{T}} where T","page":"Rolling.jl Documentation","title":"Rolling.WindowedAssociativeOpState","text":"WindowedAssociativeOpState{T}\n\nCreate a new, empty, instance of WindowedAssociativeOpState.\n\nArguments\n\nop::Function: Any binary, associative, function.\n\nReturns\n\nWindowedAssociativeOpState{T}: An empty instance.\n\n\n\n\n\n","category":"method"},{"location":"#Rolling.update_state!-Union{Tuple{T}, Tuple{FixedWindowAssociativeOp{T},Any}} where T","page":"Rolling.jl Documentation","title":"Rolling.update_state!","text":"update_state!(\n    state::FixedWindowAssociativeOp{T},\n    value\n)::Union{T, Nothing} where T\n\n\n\n\n\n","category":"method"}]
}
