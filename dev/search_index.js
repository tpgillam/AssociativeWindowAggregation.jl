var documenterSearchIndex = {"docs":
[{"location":"#Rolling.jl-Documentation","page":"Rolling.jl Documentation","title":"Rolling.jl Documentation","text":"","category":"section"},{"location":"","page":"Rolling.jl Documentation","title":"Rolling.jl Documentation","text":"Modules = [Rolling]","category":"page"},{"location":"#Rolling.FixedWindowAssociativeOp-Union{Tuple{T}, Tuple{Function,Integer}} where T","page":"Rolling.jl Documentation","title":"Rolling.FixedWindowAssociativeOp","text":"FixedWindowAssociativeOp{T}\n\n\n\n\n\n","category":"method"},{"location":"#Rolling.WindowedAssociativeOpState","page":"Rolling.jl Documentation","title":"Rolling.WindowedAssociativeOpState","text":"WindowedAssociativeOpState{T}\n\nState associated with a windowed aggregation of a binary associative operator, in a numerically accurate fashion.\n\nWherever summation is discussed, we can consider any alternative binary, associative, operator. For example: +, *, max, min, &&, union\n\nNB. It is interesting to observe that commutativity is not required by this algorithm, which is one of the reasons that it enjoys stable numerical performance.\n\nConceptually the window is maintained in two buffers:\n\n    [---- A ---)[----- B ------)\n        <                      >    <-- current window finishes at the end of B, and\n                                        starts somewhere in A.\n\nA is stored as a sequence of cumulative sums, such that as the \"<\" advances we merely pick out the correct element:\n\n    x_i,   x_i-1 + x_i,  x_i-2 + x_i-1 + x_i\n\nB is stored as both:\n\nThe sequence of values seen:  x_i+1,  x_i+2,  x_i+3,  ...\nThe total of that sequence:  x_i+1 + x_i+2 + x_i+3 + ...\n\nWhen the \"<\" advances from A to B, we discard A, and the subset of B remaining after < becomes the new A. In becoming A, we transform its representation into that of the cumulative sums. We create a new, empty, B.\n\nO(1) amortized runtime complexity, and O(L) space complexity, where L is the typical window length.\n\nFields\n\nvalue_count::Int: The size of the window on the last update.\nop::Function: Any binary, associative, function.\nprevious_cumsum::Array{T, 1}: Corresponds to array A above.\nri_previous_cumsum::Int: A reverse index into previous_cumsum, once it contains   values. It should be subtracted from end in order to obtain the appropriate index.\nvalues::Array{T, 1}: Corresponds to array B above.\nsum::Union{Nothing, T}: The sum of the elements in values.\n\n\n\n\n\n","category":"type"},{"location":"#Rolling.update_state!-Union{Tuple{T}, Tuple{FixedWindowAssociativeOp{T},Any}} where T","page":"Rolling.jl Documentation","title":"Rolling.update_state!","text":"update_state!(\n    state::FixedWindowAssociativeOp{T},\n    value\n)::Union{T, Nothing} where T\n\n\n\n\n\n","category":"method"},{"location":"#Rolling.update_state!-Union{Tuple{T}, Tuple{WindowedAssociativeOpState{T},Any,Integer}} where T","page":"Rolling.jl Documentation","title":"Rolling.update_state!","text":"update_state!(\n    state::WindowedAssociativeOpState{T},\n    value,\n    num_dropped_from_window::Integer\n)::T where T\n\nAdd the specified value to the state, drop some number of elements from the start of the window, and return the aggregated quantity.\n\nArguments\n\nstate::WindowedAssociativeOpState{T}\nvalue: The value to add to the end of the window - must be convertible to a T.\nnum_dropped_from_window::Integer: The number of elements to remove from the front of   the window.\n\nReturns\n\nT: The result of aggregating over the values in the window after adding value, and   removing num_dropped_from_window elements from the start of the window.\n\n\n\n\n\n","category":"method"}]
}
