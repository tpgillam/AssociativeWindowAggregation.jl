var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Rolling-mean","page":"Examples","title":"Rolling mean","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we show a computation of the rolling mean over fixed windows. We use a  FixedWindowAssociativeOp to keep track of a rolling sum, then divide by the window length, only including values where the window has filled.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AssociativeWindowAggregation\nusing Plots\n\nx = range(1, 10; length=100)\ny = sin.(x) + 0.5 * rand(length(x))\n\nplot(x, y; label=\"raw\", title=\"Rolling means\")\n\nfor window in [5, 10, 20]\n    # Use this to keep track of a windowed sum.\n    state = FixedWindowAssociativeOp{Float64, +}(window)\n\n    z = []\n    for value in y\n        update_state!(state, value)\n        if window_full(state)\n            push!(z, window_value(state) / window)\n        else\n            push!(z, NaN)\n        end\n    end\n\n    plot!(x, z; label=\"mean $window\", lw=2)\nend\nsavefig(\"mean-plot.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"reference/fixed_window_associative_op/#Fixed-window","page":"Fixed window","title":"Fixed window","text":"","category":"section"},{"location":"reference/fixed_window_associative_op/","page":"Fixed window","title":"Fixed window","text":"A state to represent a window with a fixed capacity. It will start off empty, can have values pushed into it, and can be tested to see if it is \"full\".","category":"page"},{"location":"reference/fixed_window_associative_op/","page":"Fixed window","title":"Fixed window","text":"Modules = [AssociativeWindowAggregation]\nPages = [\"fixed_window_associative_op.jl\"]","category":"page"},{"location":"reference/fixed_window_associative_op/#AssociativeWindowAggregation.FixedWindowAssociativeOp","page":"Fixed window","title":"AssociativeWindowAggregation.FixedWindowAssociativeOp","text":"FixedWindowAssociativeOp{T,Op}\n\nState necessary for accumulation over a rolling window of fixed size.\n\nFields\n\nwindow_state::WindowedAssociativeOp{T,Op}: The underlying general-window state.\nremaining_window::Int: How much of the window remains to be filled. Initially this will   be set to the window size, and will then reduce for every value added until it reaches   zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/fixed_window_associative_op/#AssociativeWindowAggregation.update_state!-Tuple{FixedWindowAssociativeOp, Any}","page":"Fixed window","title":"AssociativeWindowAggregation.update_state!","text":"update_state!(state::FixedWindowAssociativeOp, value)\n\nAdd the specified value to the state. Drop a value from the window iff the window is full.\n\nReturns\n\n::FixedWindowAssociativeOp: The instance state that was passed in.\n\n\n\n\n\n","category":"method"},{"location":"reference/fixed_window_associative_op/#AssociativeWindowAggregation.window_full-Tuple{FixedWindowAssociativeOp}","page":"Fixed window","title":"AssociativeWindowAggregation.window_full","text":"window_full(state::FixedWindowAssociativeOp)::Bool\n\nReturns true iff the given state has a full window.\n\n\n\n\n\n","category":"method"},{"location":"reference/time_window_associative_op/#Time-window","page":"Time window","title":"Time window","text":"","category":"section"},{"location":"reference/time_window_associative_op/","page":"Time window","title":"Time window","text":"A state to represent a window with fixed time capacity.","category":"page"},{"location":"reference/time_window_associative_op/","page":"Time window","title":"Time window","text":"Every value pushed onto the state has an associated time, and time is taken to be strictly increasing.  The window is taken to be fixed in terms of time duration rather than a fixed number of values.","category":"page"},{"location":"reference/time_window_associative_op/","page":"Time window","title":"Time window","text":"Modules = [AssociativeWindowAggregation]\nPages = [\"time_window_associative_op.jl\"]","category":"page"},{"location":"reference/time_window_associative_op/#AssociativeWindowAggregation.TimeWindowAssociativeOp","page":"Time window","title":"AssociativeWindowAggregation.TimeWindowAssociativeOp","text":"TimeWindowAssociativeOp{Value, Time, TimeDiff}\n\nState necessary for accumulation over a rolling window of fixed size, in terms of time.\n\nWhen presented with a new time t', we guarantee that all times t remaining in the window satisfy:\n\nt > t' - w\n\nThat is, at time t' this window represents the open-closed time interval (t' - w, t']\n\nFields\n\nwindow_state::WindowedAssociativeOp{Value}: The underlying general-window state.\nwindow::TimeDiff: The window, as a difference between two times.\ntimes::Deque{Time}: The same length as the values stored in window_state, and   representing the times of those observations.\nwindow_full::Bool: For internal use - will be set to true once a point has dropped out   of the window.\n\n\n\n\n\n","category":"type"},{"location":"reference/time_window_associative_op/#AssociativeWindowAggregation.update_state!-Tuple{TimeWindowAssociativeOp, Any, Any}","page":"Time window","title":"AssociativeWindowAggregation.update_state!","text":"update_state!(\n    state::TimeWindowAssociativeOp{Value,Time,TimeDiff},\n    time,\n    value\n)::TimeWindowAssociativeOp{Value,Time,TimeDiff} where {Value,Time,TimeDiff}\n\nAdd the specified value to the state with associated time, and drop any values that are no longer in the time window.\n\nArguments\n\nstate::TimeWindowAssociativeOp{Value,Time,TimeDiff}:\ntime: The time to which value corresponds.\nvalue: The value to add to the window.\n\nReturns\n\n::TimeWindowAssociativeOp{Value,Time,TimeDiff}: state, which has been mutated.\n\n\n\n\n\n","category":"method"},{"location":"reference/time_window_associative_op/#AssociativeWindowAggregation.window_full-Tuple{TimeWindowAssociativeOp}","page":"Time window","title":"AssociativeWindowAggregation.window_full","text":"window_full(state::TimeWindowAssociativeOp)::Bool\n\nReturns true iff the given state has had at least one value drop out of the window, indicating that the window is now full.\n\n\n\n\n\n","category":"method"},{"location":"reference/windowed_associative_op/#General-window","page":"General window","title":"General window","text":"","category":"section"},{"location":"reference/windowed_associative_op/","page":"General window","title":"General window","text":"A state to represent a window of aribtrarily variable capacity.","category":"page"},{"location":"reference/windowed_associative_op/","page":"General window","title":"General window","text":"Every time a new value is pushed onto the end of the window, we must specify how many values are removed from the front of the window.","category":"page"},{"location":"reference/windowed_associative_op/","page":"General window","title":"General window","text":"Modules = [AssociativeWindowAggregation]\nPages = [\"windowed_associative_op.jl\"]","category":"page"},{"location":"reference/windowed_associative_op/#AssociativeWindowAggregation.WindowedAssociativeOp","page":"General window","title":"AssociativeWindowAggregation.WindowedAssociativeOp","text":"WindowedAssociativeOp{T,Op}\n\nState associated with a windowed aggregation of a binary associative operator, in a numerically accurate fashion.\n\nWherever summation is discussed, we can consider any alternative binary, associative, operator. For example: +, *, max, min, &&, union\n\nNB. It is interesting to observe that commutativity is not required by this algorithm, which is one of the reasons that it enjoys stable numerical performance.\n\nConceptually the window is maintained in two buffers:\n\n    [---- A ---)[----- B ------)\n        <                      >    <-- current window finishes at the end of B, and\n                                        starts somewhere in A.\n\nA is stored as a sequence of cumulative sums, such that as the \"<\" advances we merely pick out the correct element:\n\n    x_i,   x_i-1 + x_i,  x_i-2 + x_i-1 + x_i\n\nB is stored as both:\n\nThe sequence of values seen:  x_i+1,  x_i+2,  x_i+3,  ...\nThe total of that sequence:  x_i+1 + x_i+2 + x_i+3 + ...\n\nWhen the \"<\" advances from A to B, we discard A, and the subset of B remaining after < becomes the new A. In becoming A, we transform its representation into that of the cumulative sums. We create a new, empty, B.\n\nO(1) amortized runtime complexity, and O(L) space complexity, where L is the typical window length.\n\nType parameters\n\nT: The type of the values of the array.\nOp: Any binary, associative, function.\nV: The abstract vector subtype used for internal state.\n\nFields\n\nprevious_cumsum::Vector{T}: Corresponds to array A above.\nri_previous_cumsum::Int: A reverse index into previous_cumsum, once it contains   values. It should be subtracted from end in order to obtain the appropriate index.\nvalues::Vector{T}: Corresponds to array B above.\nsum::T: The sum of the elements in values.\n\n\n\n\n\n","category":"type"},{"location":"reference/windowed_associative_op/#AssociativeWindowAggregation.WindowedAssociativeOp-Union{Tuple{}, Tuple{Op}, Tuple{T}} where {T, Op}","page":"General window","title":"AssociativeWindowAggregation.WindowedAssociativeOp","text":"WindowedAssociativeOp{T,Op}\n\nCreate a new, empty, instance of WindowedAssociativeOp.\n\nType parameters\n\nT: The type of the values of the array.\nOp: Any binary, associative, function.\n\n\n\n\n\n","category":"method"},{"location":"reference/windowed_associative_op/#AssociativeWindowAggregation.update_state!-Union{Tuple{Op}, Tuple{T}, Tuple{WindowedAssociativeOp{T, Op, V} where V<:AbstractVector{T}, Any, Integer}} where {T, Op}","page":"General window","title":"AssociativeWindowAggregation.update_state!","text":"update_state!(\n    state::WindowedAssociativeOp{T,Op},\n    value,\n    num_dropped_from_window::Integer\n)::WindowedAssociativeOp{T,Op} where {T,Op}\n\nAdd the specified value to the state, drop some number of elements from the start of the window, and return state (which will have been mutated).\n\nArguments\n\nstate::WindowedAssociativeOp{T,Op}: The state to update (will be mutated).\nvalue: The value to add to the end of the window - must be convertible to a T.\nnum_dropped_from_window::Integer: The number of elements to remove from the front of   the window.\n\nReturns\n\n::WindowedAssociativeOp{T,Op}: The instance state that was passed in.\n\n\n\n\n\n","category":"method"},{"location":"reference/windowed_associative_op/#AssociativeWindowAggregation.window_size-Tuple{WindowedAssociativeOp}","page":"General window","title":"AssociativeWindowAggregation.window_size","text":"function window_size(state::WindowedAssociativeOp)::Int\n\nGet the current size of the window in state.\n\nArguments:\n\nstate::WindowedAssociativeOp: The state to query.\n\nReturns:\n\nInt: The current size of the window.\n\n\n\n\n\n","category":"method"},{"location":"reference/windowed_associative_op/#AssociativeWindowAggregation.window_value-Union{Tuple{WindowedAssociativeOp{T, Op, V} where V<:AbstractVector{T}}, Tuple{Op}, Tuple{T}} where {T, Op}","page":"General window","title":"AssociativeWindowAggregation.window_value","text":"window_value(state::WindowedAssociativeOp{T,Op})::T where T\n\nGet the value currently represented by the state.\n\nArguments:\n\nstate::WindowedAssociativeOp{T,Op}: The state to query.\n\nReturns:\n\nT: The result of aggregating over the values in the window.\n\n\n\n\n\n","category":"method"},{"location":"#AssociativeWindowAggregation.jl","page":"Home","title":"AssociativeWindowAggregation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Accumulate binary associative operators over rolling windows.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Supports any binary operator that is associative (see Assumptions section for an elaboration).\nSupports a potentially variable window size.\nSupports adding values incrementally, e.g. when streaming data.\nRuns in amortized O(1) time, and uses O(L) space, where L is the typical window length.","category":"page"},{"location":"#Assumptions-and-stability","page":"Home","title":"Assumptions and stability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We assume that operators are associative. Strictly speaking this is not true for most operations on floating point numbers, however without this assumption one can do no better than O(L) time complexity. Practically, for most reasonable applications this assumption is reasonable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As detailed below, there is no long-term accumulation of errors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that we do not assume:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The existence of an inverse\nCommutativity","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider computing a rolling sum over [a, b, c, d, e] with window size 3. Ignoring the first two incomplete elements, we will emit exactly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[\n    a + b + c,\n    b + c + d,\n    c + d + e\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the most common O(1) approach to computing rolling sums uses the following approximation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[\n    a + b + c,\n    a + b + c - a + d,\n    a + b + c - a + d - b + e\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"This can be problematic due to overflow / underflow for most numerical types, and accumulated rounding errors in floating point types (for an extreme example, suppose a is Inf). The simple approach also does not generalise to operators like the set union, since there is no inverse.","category":"page"}]
}
