var documenterSearchIndex = {"docs":
[{"location":"reference/base/#General-window","page":"General window","title":"General window","text":"","category":"section"},{"location":"reference/base/","page":"General window","title":"General window","text":"A state to represent a window of aribtrarily variable capacity.","category":"page"},{"location":"reference/base/","page":"General window","title":"General window","text":"Every time a new value is pushed onto the end of the window, we must specify how many values are removed from the front of the window.","category":"page"},{"location":"reference/base/","page":"General window","title":"General window","text":"Modules = [AssociativeWindowAggregation]\nPages = [\"base.jl\"]","category":"page"},{"location":"reference/base/#AssociativeWindowAggregation.WindowedAssociativeOp","page":"General window","title":"AssociativeWindowAggregation.WindowedAssociativeOp","text":"WindowedAssociativeOp{T,Op,Op!,V<:AbstractVector{T}}(previous_cumsum::V, values::V)\nWindowedAssociativeOp{T,Op,Op!}()\nWindowedAssociativeOp{T,Op}()\n\nState associated with a windowed aggregation of a binary associative operator.\n\nIf Op! is not specified, it will default to Op.  However, for non-bitstypes, it can be beneficial to provide this method to reduce memory allocations.\n\nV will default to a Vector{T}. For windows of a fixed and known length, a circular buffer will be more efficient â€” see FixedWindowAssociativeOp.\n\nMethod\n\nWherever summation is discussed, we can consider any alternative binary, associative, operator. For example: +, *, max, min, &&, union\n\nNB. It is interesting to observe that commutativity is not required by this algorithm.\n\nConceptually the window is maintained in two buffers:\n\n    [---- A ---)[----- B ------)\n        <                      >    <-- current window finishes at the end of B, and\n                                        starts somewhere in A.\n\nA is stored as a sequence of cumulative sums, such that as the \"<\" advances we merely pick out the correct element:\n\n    x_i,   x_i-1 + x_i,  x_i-2 + x_i-1 + x_i\n\nB is stored as both:\n\nThe sequence of values seen:  x_i+1,  x_i+2,  x_i+3,  ...\nThe total of that sequence:  x_i+1 + x_i+2 + x_i+3 + ...\n\nWhen the \"<\" advances from A to B, we discard A, and the subset of B remaining after < becomes the new A. In becoming A, we transform its representation into that of the cumulative sums. We create a new, empty, B.\n\nO(1) amortized runtime complexity, and O(L) space complexity, where L is the typical window length.\n\nType parameters\n\nT: The type of the values in the window.\nOp: Any binary, associative, function.\nOp!: Op!(x, y) will perform x + y, storing the result in x.\nV: The subtype of AbstractVector{T} used for internal state.\n\nFields (for internal use only)\n\nprevious_cumsum::Vector{T}: Corresponds to array A above.\nri_previous_cumsum::Int: A reverse index into previous_cumsum, once it contains   values. It should be subtracted from end in order to obtain the appropriate index.\nvalues::Vector{T}: Corresponds to array B above.\nsum::T: The sum of the elements in values.\n\n\n\n\n\n","category":"type"},{"location":"reference/base/#AssociativeWindowAggregation.update_state!-Union{Tuple{Op!}, Tuple{Op}, Tuple{T}, Tuple{WindowedAssociativeOp{T, Op, Op!, V} where V<:AbstractVector{T}, Any, Integer}} where {T, Op, Op!}","page":"General window","title":"AssociativeWindowAggregation.update_state!","text":"update_state!(\n    state::WindowedAssociativeOp,\n    value,\n    num_dropped_from_window::Integer\n) -> state\n\nAdd the specified value to the state, drop some number of elements from the start of the window, and return state (which will have been mutated).\n\nArguments\n\nstate::WindowedAssociativeOp: The state to update (will be mutated).\nvalue: The value to add to the end of the window - must be convertible to a T.\nnum_dropped_from_window::Integer: The number of elements to remove from the front of   the window.\n\nReturns\n\nThe instance state that was passed in.\n\n\n\n\n\n","category":"method"},{"location":"reference/base/#AssociativeWindowAggregation.window_size-Tuple{WindowedAssociativeOp}","page":"General window","title":"AssociativeWindowAggregation.window_size","text":"function window_size(state::WindowedAssociativeOp)::Int\n\nGet the current size of the window in state.\n\nArguments:\n\nstate::WindowedAssociativeOp: The state to query.\n\nReturns:\n\nInt: The current size of the window.\n\n\n\n\n\n","category":"method"},{"location":"reference/base/#AssociativeWindowAggregation.window_value-Union{Tuple{WindowedAssociativeOp{T, Op, Op!, V} where {Op!, V<:AbstractVector{T}}}, Tuple{Op}, Tuple{T}} where {T, Op}","page":"General window","title":"AssociativeWindowAggregation.window_value","text":"window_value(state::WindowedAssociativeOp{T})::T where T\n\nGet the value currently represented by the state.\n\nBehaviour is undefined if this is called when the window is empty.\n\nArguments:\n\nstate::WindowedAssociativeOp{T}: The state to query.\n\nReturns:\n\nT: The result of aggregating over the values in the window.\n\n\n\n\n\n","category":"method"},{"location":"reference/time/#Time-window","page":"Time window","title":"Time window","text":"","category":"section"},{"location":"reference/time/","page":"Time window","title":"Time window","text":"A state to represent a window with fixed time capacity.","category":"page"},{"location":"reference/time/","page":"Time window","title":"Time window","text":"Every value pushed onto the state has an associated time, and time is taken to be strictly increasing.  The window is taken to be fixed in terms of time duration rather than a fixed number of values.","category":"page"},{"location":"reference/time/","page":"Time window","title":"Time window","text":"Modules = [AssociativeWindowAggregation]\nPages = [\"time.jl\"]","category":"page"},{"location":"reference/time/#AssociativeWindowAggregation.TimeWindowAssociativeOp","page":"Time window","title":"AssociativeWindowAggregation.TimeWindowAssociativeOp","text":"TimeWindowAssociativeOp{Value,Op,Op!,Time}(window::TimeDiff)\nTimeWindowAssociativeOp{Value,Op,Time}(window::TimeDiff)\n\nState necessary for accumulation over a rolling window of fixed size, in terms of time.\n\nWhen presented with a new time t', we guarantee that all times t remaining in the window satisfy:\n\nt > t' - w\n\nThat is, at time t' this window represents the open-closed time interval (t' - w, t']\n\nWe require that window be of a type that, when added to a Time, gives a Time.\n\nFields\n\nwindow_state::WindowedAssociativeOp{Value}: The underlying general-window state.\nwindow::TimeDiff: The window, as a difference between two times.\ntimes::Deque{Time}: The same length as the values stored in window_state, and   representing the times of those observations.\nwindow_full::Bool: For internal use - will be set to true once a point has dropped out   of the window.\n\n\n\n\n\n","category":"type"},{"location":"reference/time/#AssociativeWindowAggregation.update_state!-Tuple{TimeWindowAssociativeOp, Any, Any}","page":"Time window","title":"AssociativeWindowAggregation.update_state!","text":"update_state!(state::TimeWindowAssociativeOp, time, value) -> state\n\nAdd the specified value to the state with associated time, and drop any values that are no longer in the time window.\n\nArguments\n\nstate::TimeWindowAssociativeOp:\ntime: The time to which value corresponds.\nvalue: The value to add to the window.\n\nReturns\n\n::TimeWindowAssociativeOp: state, which has been mutated.\n\n\n\n\n\n","category":"method"},{"location":"reference/time/#AssociativeWindowAggregation.window_full-Tuple{TimeWindowAssociativeOp}","page":"Time window","title":"AssociativeWindowAggregation.window_full","text":"window_full(state::TimeWindowAssociativeOp)::Bool\n\nReturns true iff the given state has had at least one value drop out of the window, indicating that the window is now full.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Rolling-mean","page":"Examples","title":"Rolling mean","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we show a computation of the rolling mean over fixed windows. We could use a  FixedWindowAssociativeOp to keep track of a rolling sum, then divide by the window length, only including values where the window has filled.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AssociativeWindowAggregation\nusing Plots\n\nx = range(1, 10; length=100)\ny = sin.(x) + 0.5 * rand(length(x))\n\nplot(x, y; label=\"raw\", title=\"Rolling means\")\n\nfor window in [5, 10, 20]\n    # Use this to keep track of a windowed sum.\n    state = FixedWindowAssociativeOp{Float64,+}(window)\n\n    z = []\n    for value in y\n        update_state!(state, value)\n        if window_full(state)\n            push!(z, window_value(state) / window)\n        else\n            push!(z, NaN)\n        end\n    end\n\n    plot!(x, z; label=\"mean $window\", lw=2)\nend\nsavefig(\"mean-plot.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"However, if we were to be using very large windows, we should be nervous with the implementation above.  This is because, by taking the ratio of two large numbers, we may suffer a loss of precision.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a better implementation, where we create a new object Mean, whcih internally stores a mean and a count. We then define a merge function, which is binary and associative.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"struct Mean\n    n::Int64\n    mean::Float64\nend\nMean(x::Real) = Mean(1, x)\n\n\"\"\"\n    merge(x::Mean, y::Mean) -> Mean\n\nCombine two `Mean` objects into a new `Mean`.\n\"\"\"\nfunction merge(x::Mean, y::Mean)\n    n = x.n + y.n\n    return Mean(n, (x.n / n) * x.mean + (y.n / n) * y.mean)\nend\n\nplot(x, y; label=\"raw\", title=\"Rolling means\")\nfor window in [5, 10, 20]\n    # Unlike in the previous example, we now combine our custom `Mean` object.\n    state = FixedWindowAssociativeOp{Mean,merge}(window)\n\n    z = []\n    for value in y\n        # Wrap individual values in a `Mean` to allow us to add them to the window.\n        update_state!(state, Mean(value))\n        if window_full(state)\n            # `window_value` returns a `Mean` object now, so we must extract the mean.\n            push!(z, window_value(state).mean)\n        else\n            push!(z, NaN)\n        end\n    end\n\n    plot!(x, z; label=\"mean $window\", lw=2)\nend\nsavefig(\"mean-plot-2.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#OnlineStats.jl","page":"Examples","title":"OnlineStats.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Many of the estimators from OnlineStats.jl can be merged associatively. Therefore, we can compute online windowed versions of these statistics easily with this framework.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a simple example computing an online windowed standard deviation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AssociativeWindowAggregation\nusing OnlineStatsBase\nusing Plots\nusing Statistics\n\n# Use a window of 100 values.\nstate = FixedWindowAssociativeOp{Variance,merge,merge!}(100)\n\nfunction _wrap(v) \n    x = Variance()\n    fit!(x, v)\n    return x\nend\n\nvalues = rand(1000) .- 0.5\noutput = [std(window_value(update_state!(state, _wrap(v)))) for v in values]\n\nplot(values; alpha=0.4, label=\"Input\")\nplot!(output; label=\"std (window=100)\")\nsavefig(\"std-plot.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#AssociativeWindowAggregation.jl","page":"Home","title":"AssociativeWindowAggregation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Accumulate binary associative operators over rolling windows.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Supports any binary operator that is associative (see Assumptions section for an elaboration).\nSupports a potentially variable window size.\nSupports adding values incrementally, e.g. when streaming data.\nRuns in amortized O(1) time, and uses O(L) space, where L is the typical window length.","category":"page"},{"location":"#Assumptions-and-stability","page":"Home","title":"Assumptions and stability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We assume that operators are associative. Strictly speaking this is not true for most operations on floating point numbers, however without this assumption one can do no better than O(L) time complexity. Practically, for most reasonable applications this assumption is reasonable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As detailed below, there is no long-term accumulation of errors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that we do not assume:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The existence of an inverse\nCommutativity","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider computing a rolling sum over [a, b, c, d, e] with window size 3. Ignoring the first two incomplete elements, we will emit exactly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[\n    a + b + c,\n    b + c + d,\n    c + d + e\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the most common O(1) approach to computing rolling sums uses the following approximation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[\n    a + b + c,\n    a + b + c - a + d,\n    a + b + c - a + d - b + e\n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"This can be problematic due to overflow / underflow for most numerical types, and accumulated rounding errors in floating point types (for an extreme example, suppose a is Inf). The simple approach also does not generalise to operators like the set union, since there is no inverse.","category":"page"},{"location":"reference/fixed/#Fixed-window","page":"Fixed window","title":"Fixed window","text":"","category":"section"},{"location":"reference/fixed/","page":"Fixed window","title":"Fixed window","text":"A state to represent a window with a fixed capacity. It will start off empty, can have values pushed into it, and can be tested to see if it is \"full\".","category":"page"},{"location":"reference/fixed/","page":"Fixed window","title":"Fixed window","text":"Modules = [AssociativeWindowAggregation]\nPages = [\"fixed.jl\"]","category":"page"},{"location":"reference/fixed/#AssociativeWindowAggregation.FixedWindowAssociativeOp","page":"Fixed window","title":"AssociativeWindowAggregation.FixedWindowAssociativeOp","text":"FixedWindowAssociativeOp{T,Op,Op!}(window)\nFixedWindowAssociativeOp{T,Op}(window)\n\nState necessary for accumulation over a rolling window of fixed size.\n\nFields\n\nwindow_state::WindowedAssociativeOp{T,Op}: The underlying general-window state.\nremaining_window::Int: How much of the window remains to be filled. Initially this will   be set to the window size, and will then reduce for every value added until it reaches   zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/fixed/#AssociativeWindowAggregation.update_state!-Tuple{FixedWindowAssociativeOp, Any}","page":"Fixed window","title":"AssociativeWindowAggregation.update_state!","text":"update_state!(state::FixedWindowAssociativeOp, value) -> state\n\nAdd the specified value to the state. Drop a value from the window iff the window is full.\n\nReturns\n\n::FixedWindowAssociativeOp: The instance state that was passed in.\n\n\n\n\n\n","category":"method"},{"location":"reference/fixed/#AssociativeWindowAggregation.window_full-Tuple{FixedWindowAssociativeOp}","page":"Fixed window","title":"AssociativeWindowAggregation.window_full","text":"window_full(state::FixedWindowAssociativeOp)::Bool\n\nReturns true iff the given state has a full window.\n\n\n\n\n\n","category":"method"}]
}
